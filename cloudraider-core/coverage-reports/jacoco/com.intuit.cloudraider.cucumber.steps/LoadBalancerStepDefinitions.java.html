<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>LoadBalancerStepDefinitions.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">cloudraider-core</a> &gt; <a href="index.source.html" class="el_package">com.intuit.cloudraider.cucumber.steps</a> &gt; <span class="el_source">LoadBalancerStepDefinitions.java</span></div><h1>LoadBalancerStepDefinitions.java</h1><pre class="source lang-java linenums">/*
 * Apache 2.0 License
 *
 * Copyright (c) 2019 Intuit Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the &quot;Software&quot;), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

package com.intuit.cloudraider.cucumber.steps;

import com.intuit.cloudraider.core.impl.ApplicationLoadBalancerRaiderImpl;
import com.intuit.cloudraider.core.impl.LoadBalancerRaiderImpl;
import com.intuit.cloudraider.core.interfaces.EC2Raider;
import com.intuit.cloudraider.core.interfaces.LoadBalancerRaider;
import com.intuit.cloudraider.cucumber.model.ExecutionStateCache;
import com.intuit.cloudraider.model.Credentials;
import com.intuit.cloudraider.model.EC2InstanceTO;
import com.intuit.cloudraider.utils.Ec2Utils;
import com.intuit.cloudraider.utils.Randomizer;
import cucumber.api.java.en.Given;
import cucumber.api.java.en.Then;
import cucumber.api.java.en.When;
import org.junit.Assert;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

/**
 * Cucumber Step Definitions for ALB and ELB functionality.
 */
public class LoadBalancerStepDefinitions {

    private LoadBalancerRaider loadBalancerRaider;

    @Autowired
    @Qualifier(&quot;ec2raiderBean&quot;)
    private EC2Raider ec2Raider;

    @Autowired
    private ExecutionStateCache executionStateCache;

    /**
     * The Logger.
     */
<span class="nc" id="L67">    Logger logger = LoggerFactory.getLogger(this.getClass());</span>

    @Autowired
   // @Qualifier(&quot;credentials&quot;)
    private Credentials credentials;


    @Autowired
    private ApplicationLoadBalancerRaiderImpl applicationLoadBalancerRaider;

    @Autowired
    private LoadBalancerRaiderImpl elasticLoadBalancerRaider;

<span class="nc" id="L80">    public LoadBalancerStepDefinitions() {</span>

<span class="nc" id="L82">    }</span>

    public ExecutionStateCache getExecutionStateCache() {
<span class="nc" id="L85">        return executionStateCache;</span>
    }

    public void setExecutionStateCache(ExecutionStateCache executionStateCache) {
<span class="nc" id="L89">        this.executionStateCache = executionStateCache;</span>
<span class="nc" id="L90">    }</span>

    /**
     * Sets the load balancer to use along with its attached instances.
     *
     * @param loadbalancerType type of the load balancer (ELB, ALB, NLB)
     * @param loadBalancerName name of the load balancer
     */
    @Given(&quot;^(ELB|ALB|NLB) \&quot;([^\&quot;]*)\&quot;$&quot;)
    public LoadBalancerStepDefinitions givenLoadBalancerName(String loadbalancerType, String loadBalancerName) throws Throwable {

<span class="nc bnc" id="L101" title="All 2 branches missed.">        if (loadbalancerType.equalsIgnoreCase(&quot;ELB&quot;)) {</span>
<span class="nc" id="L102">            loadBalancerRaider = elasticLoadBalancerRaider;</span>
        } else {
<span class="nc" id="L104">            loadBalancerRaider = applicationLoadBalancerRaider;</span>
        }

<span class="nc" id="L107">        executionStateCache.setLoadBalancerName(loadBalancerName);</span>
<span class="nc" id="L108">        executionStateCache.clearInstances();</span>
<span class="nc" id="L109">        executionStateCache.addInstances(ec2Raider.getEC2InstancesByIds(findAllInServiceInstances()));</span>
<span class="nc" id="L110">        return this;</span>
    }

    public void givenLoadBalancerNameIgnoreExecCache(String loadbalancerType, String loadBalancerName) {
<span class="nc bnc" id="L114" title="All 2 branches missed.">        if (loadbalancerType.equalsIgnoreCase(&quot;ELB&quot;)) {</span>
<span class="nc" id="L115">            loadBalancerRaider = elasticLoadBalancerRaider;</span>
        } else {
<span class="nc" id="L117">            loadBalancerRaider = applicationLoadBalancerRaider;</span>
        }

<span class="nc" id="L120">        executionStateCache.setLoadBalancerName(loadBalancerName);</span>
<span class="nc" id="L121">        executionStateCache.clearInstances();</span>
<span class="nc" id="L122">    }</span>

    /**
     * Gets all load balancers, of any type, associated with the provided account.
     *
     * @return Map of (Load Balancer Name, Load Balancer Type)
     */
    public Map&lt;String, String&gt; getLoadBalancerNames() {
<span class="nc" id="L130">        Map&lt;String, String&gt; map = applicationLoadBalancerRaider.getLoadBalancerNames();</span>
<span class="nc" id="L131">        map.putAll(loadBalancerRaider.getLoadBalancerNames());</span>
<span class="nc" id="L132">        return map;</span>
    }

    /**
     * Detaches the given security group from the load balancer.
     *
     * @param securityGroupId security group id
     */
    @Given(&quot;^detach security-group \&quot;([^\&quot;]*)\&quot;$&quot;)
    public LoadBalancerStepDefinitions detachSecurityGroup(String securityGroupId) {
<span class="nc" id="L142">        executionStateCache.addDetachedSecurityGroup(securityGroupId);</span>
<span class="nc" id="L143">        logger.info(&quot;Detaching security group &quot; + securityGroupId + &quot; from &quot; + executionStateCache.getLoadBalancerName());</span>
<span class="nc" id="L144">        loadBalancerRaider.deleteSecurityGroups(executionStateCache.getLoadBalancerName(), securityGroupId);</span>
<span class="nc" id="L145">        return this;</span>
    }

    /**
     * Attaches the given security group to the load balancer.
     *
     * @param securityGroupId security group id
     */
    @Given(&quot;^attach security-group \&quot;([^\&quot;]*)\&quot;$&quot;)
    public LoadBalancerStepDefinitions attachSecurityGroup(String securityGroupId) {
<span class="nc" id="L155">        loadBalancerRaider.addSecurityGroups(executionStateCache.getLoadBalancerName(), securityGroupId);</span>
<span class="nc" id="L156">        return this;</span>
    }

    /**
     * Randomly detaches the given number of security groups from the load balancer. If the number is larger than the
     * number of attached security groups, all available security groups are detached. NOTE that the load balancer
     * requires at least one security group to function, so one group will always be left over.
     *
     * @param num number of security groups to detach
     */
    @Given(&quot;^detach (\\d+) security-groups$&quot;)
    public LoadBalancerStepDefinitions detachRandomSecurityGroups(int num) {
<span class="nc" id="L168">        List&lt;String&gt; groups = loadBalancerRaider.getSecurityGroups(executionStateCache.getLoadBalancerName());</span>
<span class="nc bnc" id="L169" title="All 4 branches missed.">        if (groups == null || groups.isEmpty()) {</span>
<span class="nc" id="L170">            throw new RuntimeException(&quot;No groups are available&quot;);</span>
        }
<span class="nc bnc" id="L172" title="All 2 branches missed.">        if (num &gt; groups.size()) {</span>
<span class="nc" id="L173">            num = groups.size();</span>
        }
<span class="nc bnc" id="L175" title="All 2 branches missed.">        for (int i = 0; i &lt; num; i++) {</span>
<span class="nc" id="L176">            groups = loadBalancerRaider.getSecurityGroups(executionStateCache.getLoadBalancerName());</span>
<span class="nc" id="L177">            String group = groups.get(Randomizer.generateInt(0, groups.size()));</span>
<span class="nc bnc" id="L178" title="All 2 branches missed.">            if (executionStateCache.getDetachedSecurityGroups().contains(group)) {</span>
<span class="nc" id="L179">                i--;</span>
<span class="nc" id="L180">                continue;</span>
            }
<span class="nc" id="L182">            executionStateCache.addDetachedSecurityGroup(group);</span>
<span class="nc" id="L183">            logger.info(&quot;Detaching security group &quot; + group + &quot; from &quot; + executionStateCache.getLoadBalancerName());</span>
<span class="nc" id="L184">            loadBalancerRaider.deleteSecurityGroups(executionStateCache.getLoadBalancerName(), group);</span>
        }
<span class="nc" id="L186">        return this;</span>
    }

    /**
     * Attach removed security groups to the load balancer.
     */
    @Given(&quot;^attach removed security-groups$&quot;)
    public LoadBalancerStepDefinitions attachRandomRemovedSecurityGroups() {
<span class="nc bnc" id="L194" title="All 2 branches missed.">        for (String group : executionStateCache.getDetachedSecurityGroups()) {</span>
<span class="nc" id="L195">            loadBalancerRaider.addSecurityGroups(executionStateCache.getLoadBalancerName(), group);</span>
<span class="nc" id="L196">        }</span>
<span class="nc" id="L197">        executionStateCache.removeDetachedSecurityGroups(executionStateCache.getDetachedSecurityGroups());</span>
<span class="nc" id="L198">        return this;</span>
    }

    /**
     * Detaches the given subnet from the load balancer.
     *
     * @param subnetId subnet id
     */
    @Given(&quot;^detach subnet \&quot;([^\&quot;]*)\&quot;$&quot;)
    public LoadBalancerStepDefinitions detachSubnet(String subnetId) {
<span class="nc" id="L208">        executionStateCache.addDetachedSubnet(subnetId);</span>
<span class="nc" id="L209">        logger.info(&quot;Detaching subnet &quot; + subnetId + &quot; from &quot; + executionStateCache.getLoadBalancerName());</span>
<span class="nc" id="L210">        loadBalancerRaider.detachLoadBalancerFromSubnets(executionStateCache.getLoadBalancerName(), subnetId);</span>
<span class="nc" id="L211">        return this;</span>
    }

    /**
     * Randomly detaches the given number of subnets from the load balancer. If the number is larger than the
     * number of attached subnets, all available subnets are detached. NOTE that the load balancer requires at least
     * two subnets to function, so two subnets will always be left over.
     *
     * @param num number of subnets to detach
     */
    @Given(&quot;^detach (\\d+) subnets$&quot;)
    public LoadBalancerStepDefinitions detachRandomSubnets(int num) {
<span class="nc" id="L223">        List&lt;String&gt; subnets = loadBalancerRaider.getLoadBalancerSubnets(executionStateCache.getLoadBalancerName());</span>
<span class="nc bnc" id="L224" title="All 4 branches missed.">        if (subnets == null || subnets.isEmpty()) {</span>
<span class="nc" id="L225">            throw new RuntimeException(&quot;No subnets are available&quot;);</span>
        }
<span class="nc bnc" id="L227" title="All 2 branches missed.">        if (num &gt; subnets.size()) {</span>
<span class="nc" id="L228">            num = subnets.size();</span>
        }
<span class="nc bnc" id="L230" title="All 2 branches missed.">        for (int i = 0; i &lt; num; i++) {</span>
<span class="nc" id="L231">            subnets = loadBalancerRaider.getLoadBalancerSubnets(executionStateCache.getLoadBalancerName());</span>
<span class="nc" id="L232">            String subnet = subnets.get(Randomizer.generateInt(0, subnets.size()));</span>
<span class="nc bnc" id="L233" title="All 2 branches missed.">            if (executionStateCache.getDetachedSubnets().contains(subnet)) {</span>
<span class="nc" id="L234">                i--;</span>
<span class="nc" id="L235">                continue;</span>
            }
<span class="nc" id="L237">            executionStateCache.addDetachedSubnet(subnet);</span>
<span class="nc" id="L238">            logger.info(&quot;Detaching subnet &quot; + subnet + &quot; from &quot; + executionStateCache.getLoadBalancerName());</span>
<span class="nc" id="L239">            loadBalancerRaider.detachLoadBalancerFromSubnets(executionStateCache.getLoadBalancerName(), subnet);</span>
        }
<span class="nc" id="L241">        return this;</span>
    }

    /**
     * Attach removed subnets to the load balancer.
     */
    @Given(&quot;^attach removed subnets$&quot;)
    public LoadBalancerStepDefinitions attachRandomRemovedSubnets() {
<span class="nc bnc" id="L249" title="All 2 branches missed.">        for (String subnet : executionStateCache.getDetachedSubnets()) {</span>
<span class="nc" id="L250">            loadBalancerRaider.attachLoadBalancerToSubnets(executionStateCache.getLoadBalancerName(), subnet);</span>
<span class="nc" id="L251">        }</span>
<span class="nc" id="L252">        executionStateCache.removeDetachedSubnets(executionStateCache.getDetachedSubnets());</span>
<span class="nc" id="L253">        return this;</span>
    }

    /**
     * Attach the provided subnet to the load balancer.
     *
     * @param subnetId subnet id
     */
    @Given(&quot;^attach subnet \&quot;([^\&quot;]*)\&quot;$&quot;)
    public LoadBalancerStepDefinitions attachSubnet(String subnetId) {
<span class="nc" id="L263">        executionStateCache.removeDetachedSubnet(subnetId);</span>
<span class="nc" id="L264">        loadBalancerRaider.attachLoadBalancerToSubnets(executionStateCache.getLoadBalancerName(), subnetId);</span>
<span class="nc" id="L265">        return this;</span>
    }

    /**
     * Assert that the number of healthy hosts attached to the load balancer matches what is expected.
     *
     * @param expected expected number of healthy hosts
     */
    @Then(&quot;^assertEC2 healthy host count = (\\d+)$&quot;)
    public void assertHealthyHostCount(int expected) throws Throwable {
<span class="nc" id="L275">        logger.info(&quot;healthy host count &quot; + findAllInServiceInstances().size());</span>
<span class="nc" id="L276">        Assert.assertTrue(&quot;Healthy host count mismatched &quot;, this.confirmHealthyHostCount(expected));</span>
<span class="nc" id="L277">    }</span>

    /**
     * Assert that the number of unhealthy hosts attached to the load balancer matches what is expected.
     *
     * @param expected expected number of unhealthy hosts
     */
    @Then(&quot;^assertEC2 unhealthy host count = (\\d+)$&quot;)
    public void assertUntHealthyHostCount(int expected) throws Throwable {
<span class="nc" id="L286">        Assert.assertFalse(&quot;Unhealthy host count mismatched &quot;, this.confirmHealthyHostCount(expected));</span>
<span class="nc" id="L287">    }</span>

    /**
     * Corrupt the load balancer's health check process so that it no longer works properly,
     */
    @When(&quot;^LB corrupt HealthChecks$&quot;)
    public void corruptLBHealthCheck() throws Throwable {
<span class="nc" id="L294">        loadBalancerRaider.forceFailLoadbalancerHealthCheck(executionStateCache.getLoadBalancerName());</span>
<span class="nc" id="L295">    }</span>

    /**
     * Return the load balancer's health check process back to working condition.
     */
    @Then(&quot;^LB unCorrupt HealthChecks$&quot;)
    public void unCorruptLBHealthCheck() throws Throwable {
<span class="nc" id="L302">        loadBalancerRaider.undoForceFailLoadbalancerHealthCheck(executionStateCache.getLoadBalancerName());</span>
<span class="nc" id="L303">    }</span>

    /**
     * De-register the given instance from the load balancer.
     *
     * @param instanceID instance id
     */
    @When(&quot;^detach instanceId \&quot;([^\&quot;]*)\&quot; from loadbalancer$&quot;)
    public void deRegisterGivenInstance(String instanceID) {
<span class="nc" id="L312">        List&lt;String&gt; list = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L313">        list.add(instanceID);</span>
<span class="nc" id="L314">        logger.info(&quot;Detaching instance  &quot; + instanceID + &quot; from &quot; + executionStateCache.getLoadBalancerName());</span>
<span class="nc" id="L315">        executionStateCache.addDeregisteredInstance(executionStateCache.findEC2InstanceGivenID(instanceID));</span>
<span class="nc" id="L316">        loadBalancerRaider.deregisterInstancesFromLoadBalancer(executionStateCache.getLoadBalancerName(), list);</span>
<span class="nc" id="L317">    }</span>

    /**
     * Detach the given percentage of instances attached to the load balancer, choosing randomly once the number of
     * instances to detach is determined.
     *
     * @param percentage percentage of instances (0 to 100 inclusive)
     */
//    @When(&quot;^detach (\\d+)% instances from loadbalancer$&quot;)
    public LoadBalancerStepDefinitions deRegisterPercentOfInstances(double percentage) {
<span class="nc" id="L327">        List&lt;EC2InstanceTO&gt; instances = executionStateCache.getInstances();</span>
<span class="nc" id="L328">        int numInstances = (int) Math.round((percentage * instances.size())/100);</span>

<span class="nc bnc" id="L330" title="All 2 branches missed.">        if (instances.isEmpty()) {</span>
<span class="nc" id="L331">            throw new RuntimeException(&quot;No Instances are available&quot;);</span>
        }

<span class="nc" id="L334">        List&lt;EC2InstanceTO&gt; instanceList = instances;</span>
<span class="nc bnc" id="L335" title="All 2 branches missed.">        if (instanceList.size() != numInstances) {</span>
<span class="nc" id="L336">            instanceList = instances.subList(0,numInstances);</span>
        }

<span class="nc" id="L339">        loadBalancerRaider.deregisterInstancesFromLoadBalancer(executionStateCache.getLoadBalancerName(), Ec2Utils.generateInstanceIdList(instanceList));</span>
<span class="nc" id="L340">        executionStateCache.addDeregisteredInstance(instanceList);</span>

<span class="nc" id="L342">        return this;</span>
    }

    /**
     * Detach the provided number of instances that are attached to the load balancer.
     *
     * @param numInstances number of instances
     */
    @When(&quot;^detach (\\d+) instances from loadbalancer$&quot;)
    public LoadBalancerStepDefinitions deRegisterInstances(int numInstances) {
<span class="nc" id="L352">        List&lt;EC2InstanceTO&gt; instances = executionStateCache.getInstances();</span>

<span class="nc bnc" id="L354" title="All 4 branches missed.">        if (instances == null || instances.isEmpty())</span>
        {
<span class="nc" id="L356">            throw new RuntimeException(&quot;No Instances are vailable&quot;);</span>
        }

<span class="nc" id="L359">        logger.info(&quot;number of available instances: &quot; + instances.size());</span>
<span class="nc bnc" id="L360" title="All 2 branches missed.">        if (numInstances &gt; instances.size()) {</span>
<span class="nc" id="L361">            numInstances = instances.size();</span>
        }

<span class="nc" id="L364">        List&lt;EC2InstanceTO&gt; instanceList = instances;</span>
<span class="nc bnc" id="L365" title="All 2 branches missed.">        if (instanceList.size() != numInstances) {</span>
<span class="nc" id="L366">            instanceList = instances.subList(0, numInstances);</span>
        }

<span class="nc" id="L369">        logger.info(&quot;Detaching instances &quot; + instanceList.stream().map(x -&gt; x.getInstanceId()).collect(Collectors.toList())</span>
<span class="nc" id="L370">                + &quot; from &quot; + executionStateCache.getLoadBalancerName());</span>

<span class="nc" id="L372">        loadBalancerRaider.deregisterInstancesFromLoadBalancer(executionStateCache.getLoadBalancerName(), Ec2Utils.generateInstanceIdList(instanceList));</span>
<span class="nc" id="L373">        executionStateCache.addDeregisteredInstance(instanceList);</span>

<span class="nc" id="L375">        return this;</span>
    }

    /**
     * Detach the percentage of instances that are attached to the load balancer.
     *
     * @param percentage number of instances
     */
    @When(&quot;^detach (\\d+)% instances from loadbalancer$&quot;)
    public LoadBalancerStepDefinitions deRegisterPercentOfInstances(int percentage)
    {
<span class="nc" id="L386">        List&lt;EC2InstanceTO&gt; instances = executionStateCache.getInstances();</span>
<span class="nc" id="L387">        int numInstances = Math.round((percentage * instances.size())/100);</span>

<span class="nc bnc" id="L389" title="All 4 branches missed.">        if (instances == null || instances.isEmpty())</span>
        {
<span class="nc" id="L391">            throw new RuntimeException(&quot;No Instances are vailable&quot;);</span>
        }

<span class="nc" id="L394">        List&lt;EC2InstanceTO&gt; instanceList = instances;</span>
<span class="nc bnc" id="L395" title="All 2 branches missed.">        if (instanceList.size() != numInstances)</span>
        {
<span class="nc" id="L397">            instanceList = instances.subList(0,numInstances);</span>
        }


<span class="nc" id="L401">        loadBalancerRaider.deregisterInstancesFromLoadBalancer(executionStateCache.getLoadBalancerName(),Ec2Utils.generateInstanceIdList(instanceList));</span>
<span class="nc" id="L402">        executionStateCache.addDeregisteredInstance(instanceList);</span>

<span class="nc" id="L404">        return this;</span>

    }


    @When(&quot;^attach unregistered instances$&quot;)
    public LoadBalancerStepDefinitions registerInstances() {
<span class="nc" id="L411">        List&lt;EC2InstanceTO&gt; instances = executionStateCache.getDeregistedInstance();</span>
<span class="nc bnc" id="L412" title="All 4 branches missed.">        if (instances == null || instances.isEmpty()) {</span>
<span class="nc" id="L413">            throw new RuntimeException(&quot;No Instances are available&quot;);</span>
        }

<span class="nc" id="L416">        loadBalancerRaider.registerInstancesFromLoadBalancer(executionStateCache.getLoadBalancerName(), Ec2Utils.generateInstanceIdList(instances));</span>
<span class="nc" id="L417">        executionStateCache.clearDeregisteredInstance();</span>

<span class="nc" id="L419">        return this;</span>
    }

    /**
     * Checks if the number of unhealthy hosts matches what is expected.
     *
     * @param expected expected number
     * @return true if the expected number and the actual number match
     */
    public boolean confirmUnHealthyHostCount(int expected) {
<span class="nc bnc" id="L429" title="All 2 branches missed.">        return (findAllOutOfServiceInstances().size() == expected);</span>
    }

    /**
     * Checks if the number of healthy hosts matches what is expected.
     *
     * @param expected expected number
     * @return true if the expected number and the actual number match
     */
    public boolean confirmHealthyHostCount(int expected) throws Throwable {
<span class="nc bnc" id="L439" title="All 2 branches missed.">        return (findAllInServiceInstances().size() == expected);</span>
    }

    /**
     * Returns list of security groups attached to the load balancer.
     *
     * @return list of security group ids
     */
    public List&lt;String&gt; getSecurityGroups() {
<span class="nc" id="L448">        return loadBalancerRaider.getSecurityGroups(executionStateCache.getLoadBalancerName());</span>
    }

    /**
     * Returns list of subnets attached to the load balancer.
     *
     * @return list of subnet ids
     */
    public List&lt;String&gt; getSubnets() {
<span class="nc" id="L457">        return loadBalancerRaider.getLoadBalancerSubnets(executionStateCache.getLoadBalancerName());</span>
    }

    /**
     * Returns list of in service instances attached to the load balancer.
     *
     * @return list of in service instances
     */
    public List&lt;String&gt; findAllInServiceInstances() {
<span class="nc" id="L466">        List&lt;String&gt; instances = null;</span>

<span class="nc bnc" id="L468" title="All 2 branches missed.">        if (executionStateCache.getLoadBalancerName() == null) {</span>
<span class="nc" id="L469">            throw new RuntimeException(&quot;LoadBalancer Name is not provided&quot;);</span>
        }

<span class="nc" id="L472">        instances = loadBalancerRaider.getInServiceInstances(executionStateCache.getLoadBalancerName());</span>
<span class="nc" id="L473">        return instances;</span>
    }

    /**
     * Returns list of in service instances attached to the load balancer provided.
     *
     * @param loadBalancerName load balancer name
     * @return list of in service instances
     */
    public List&lt;String&gt; findAllInServiceInstances(String loadBalancerName) {
<span class="nc" id="L483">        return loadBalancerRaider.getInServiceInstances(loadBalancerName);</span>
    }

    /**
     * Returns list of out of service instances attached to the load balancer.
     *
     * @return list of out of service instances
     */
    public List&lt;String&gt; findAllOutOfServiceInstances() {
<span class="nc" id="L492">        List&lt;String&gt; instances = null;</span>

<span class="nc bnc" id="L494" title="All 2 branches missed.">        if (executionStateCache.getLoadBalancerName() == null) {</span>
<span class="nc" id="L495">            throw new RuntimeException(&quot;LoadBalancer Name is not provided&quot;);</span>
        }

<span class="nc" id="L498">        instances = loadBalancerRaider.getOutOfServiceInstances(executionStateCache.getLoadBalancerName());</span>
<span class="nc" id="L499">        return instances;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.3.201901230119</span></div></body></html>