<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SSMStepDefinitions.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">cloudraider-core</a> &gt; <a href="index.source.html" class="el_package">com.intuit.cloudraider.cucumber.steps</a> &gt; <span class="el_source">SSMStepDefinitions.java</span></div><h1>SSMStepDefinitions.java</h1><pre class="source lang-java linenums">/*
 * Apache 2.0 License
 *
 * Copyright (c) 2019 Intuit Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the &quot;Software&quot;), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

package com.intuit.cloudraider.cucumber.steps;

import com.intuit.cloudraider.core.interfaces.SSMRaider;
import com.intuit.cloudraider.cucumber.interfaces.EC2StepFunctions;
import com.intuit.cloudraider.cucumber.model.ExecutionStateCache;
import com.intuit.cloudraider.model.Command;
import com.intuit.cloudraider.model.EC2InstanceTO;
import com.intuit.cloudraider.utils.CommandUtility;
import com.intuit.cloudraider.utils.Ec2Utils;
import cucumber.api.java.en.When;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/**
 * Cucumber Step Definitions for AWS Systems Manager functionality.
 */
public class SSMStepDefinitions implements EC2StepFunctions {

    @Autowired
    @Qualifier(&quot;ssmRaiderBean&quot;)
    private SSMRaider ssmRaider;

    /**
     * The Logger.
     */
<span class="nc" id="L56">    Logger logger = LoggerFactory.getLogger(this.getClass());</span>

    @Autowired
    private ExecutionStateCache executionStateCache;

    /**
     * Instantiates a new Ssm step definitions.
     */
<span class="nc" id="L64">    public SSMStepDefinitions() {</span>
<span class="nc" id="L65">    }</span>

    /**
     * Gets execution state cache.
     *
     * @return the execution state cache
     */
    public ExecutionStateCache getExecutionStateCache() {
<span class="nc" id="L73">        return executionStateCache;</span>
    }

    public void setExecutionStateCache(ExecutionStateCache executionStateCache) {
<span class="nc" id="L77">        this.executionStateCache = executionStateCache;</span>
<span class="nc" id="L78">    }</span>

    /**
     * Executes the given command on the specified number of instances.
     *
     * @param command  command to execute
     * @param numHosts number of instances
     * @return the ssm step definitions
     */
    @When(&quot;^executeCommand  \&quot;([^\&quot;]*)\&quot; on (\\d+) instance$&quot;)
    public SSMStepDefinitions executeCommandOnHealthyInstances(String command, int numHosts) {

<span class="nc" id="L90">        List&lt;EC2InstanceTO&gt; instanceList = getInstancesForExecution(numHosts);</span>
<span class="nc" id="L91">        List&lt;String&gt; commands = Arrays.asList(command.split(&quot;\\s*,\\s*&quot;));</span>

<span class="nc" id="L93">        String commandId = ssmRaider.executeShellCommands(Ec2Utils.generateInstanceIdList(instanceList), commands);</span>
<span class="nc" id="L94">        executionStateCache.setCommandId(commandId);</span>
<span class="nc" id="L95">        executionStateCache.setSsmCommandInvocationInstances(instanceList);</span>

<span class="nc" id="L97">        return this;</span>
    }

    /**
     * Terminate the given process on the instance.
     *
     * @param processName process name
     * @param instanceID instance id
     * @param instanceIP instance private ip
     */
    @Override
    public void terminateProcessGivenInstance(String processName, String instanceID, String instanceIP) {
<span class="nc" id="L109">        List&lt;String&gt; list = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L110">        list.add(instanceID);</span>

<span class="nc" id="L112">        executionStateCache.addProcessName(processName);</span>
<span class="nc" id="L113">        String commandId = ssmRaider.executeShellCommand(list, Command.KILLPROCESS, processName);</span>

<span class="nc" id="L115">        executionStateCache.setCommandId(commandId);</span>
<span class="nc" id="L116">        executionStateCache.addSsmCommandInvocationInstances(executionStateCache.findEC2InstanceGivenID(instanceID));</span>
<span class="nc" id="L117">        executionStateCache.setHealProcess(true);</span>
<span class="nc" id="L118">    }</span>

    /**
     * Terminate the given process on the specified number of instances.
     *
     * @param processName process name
     * @param numHosts    number of instances
     * @return the ssm step definitions
     */
    @When(&quot;^SSM terminate process  \&quot;([^\&quot;]*)\&quot; on (\\d+) instance$&quot;)
    public SSMStepDefinitions terminateCommandOnHealthyInstances(String processName, int numHosts) {
<span class="nc" id="L129">        List&lt;EC2InstanceTO&gt; instanceList = getInstancesForExecution(numHosts);</span>

<span class="nc" id="L131">        executionStateCache.addProcessName(processName);</span>
<span class="nc" id="L132">        String commandId = ssmRaider.executeShellCommand(Ec2Utils.generateInstanceIdList(instanceList), Command.KILLPROCESS, processName);</span>

<span class="nc" id="L134">        executionStateCache.setCommandId(commandId);</span>
<span class="nc" id="L135">        executionStateCache.setSsmCommandInvocationInstances(instanceList);</span>
<span class="nc" id="L136">        executionStateCache.setHealProcess(true);</span>

<span class="nc" id="L138">        return this;</span>
    }

    /**
     * Assert that current execution status matches what is expected
     *
     * @param expectedCommandStatus expected status
     */
    @When(&quot;^assertCommand execution status = \&quot;([^\&quot;]*)\&quot;$&quot;)
    public void assertCommandExecutionStatus(final String expectedCommandStatus) {
<span class="nc" id="L148">        String commandId = executionStateCache.getCommandId();</span>
<span class="nc" id="L149">        List&lt;EC2InstanceTO&gt; instances = executionStateCache.getSsmCommandInvocationInstances();</span>
<span class="nc bnc" id="L150" title="All 4 branches missed.">        if (commandId == null || commandId.isEmpty()) {</span>
<span class="nc" id="L151">            throw new RuntimeException(&quot;Missing command-id information, unable to check status&quot;);</span>
        }

<span class="nc bnc" id="L154" title="All 4 branches missed.">        if (instances == null || instances.isEmpty()) {</span>
<span class="nc" id="L155">            throw new RuntimeException(&quot;No instances are available to check command execution status&quot;);</span>
        }

<span class="nc" id="L158">        instances.stream().forEach(</span>
                instanceTO -&gt;
                {
<span class="nc" id="L161">                    String actualCommandStatus = ssmRaider.getCommandStatus(commandId, instanceTO.getInstanceId());</span>
<span class="nc" id="L162">                    org.testng.Assert.assertEquals(actualCommandStatus, expectedCommandStatus);</span>
<span class="nc" id="L163">                }</span>
        );

<span class="nc" id="L166">    }</span>

    /**
     * Terminate the given process on the specified number of instances within the denoted availability zone.
     *
     * @param processName process to terminate
     * @param numHosts    number of hosts
     * @param zoneId      availability zone id
     * @return the ssm step definitions
     */
    @When(&quot;^SSM terminate process  \&quot;([^\&quot;]*)\&quot; on (\\d+) instance in zone \&quot;([^\&quot;]*)\&quot;$&quot;)
    public SSMStepDefinitions terminateProcessInAvailabilityZone(String processName, int numHosts, String zoneId) {
<span class="nc" id="L178">        this.executeCommand(numHosts, Command.KILLPROCESS, processName);</span>
<span class="nc" id="L179">        executionStateCache.addProcessName(processName);</span>
<span class="nc" id="L180">        executionStateCache.setHealProcess(true);</span>

<span class="nc" id="L182">        return this;</span>
    }

    /**
     * Spike the given number of cores on the instance.
     *
     * @param cores number of cores
     * @param instanceID instance id
     * @param instanceIP instance private ip
     */
    @Override
    public void spikeCPUGivenInstance(int cores, String instanceID, String instanceIP) {
<span class="nc" id="L194">        List&lt;String&gt; commands = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L195">        List&lt;String&gt; list = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L196">        list.add(instanceID);</span>

<span class="nc bnc" id="L198" title="All 2 branches missed.">        for (int i = 0; i &lt; cores; i++) {</span>
<span class="nc" id="L199">            commands.addAll(CommandUtility.getCommandsFromFile(Command.SPIKECPU.getCommandName() + &quot;.txt&quot;));</span>
        }

<span class="nc" id="L202">        String commandId = ssmRaider.executeShellCommands(list, commands);</span>

<span class="nc" id="L204">        executionStateCache.setCpuSpiked(true);</span>
<span class="nc" id="L205">        executionStateCache.setCommandId(commandId);</span>
<span class="nc" id="L206">        executionStateCache.addSsmCommandInvocationInstances(executionStateCache.findEC2InstanceGivenID(instanceID));</span>
<span class="nc" id="L207">    }</span>

    /**
     * Spikes the given number of cores on each instance for the specified number of instances.
     *
     * @param numHosts number of instances
     * @param cores    number of cores to spike
     * @return the ssm step definitions
     * @throws Exception the exception
     */
    @When(&quot;^SSM CPU spike on (\\d+) instances for (\\d+) cores$&quot;)
    public SSMStepDefinitions spikeCPUOnHealthyInstances(int numHosts, int cores) throws Exception {
<span class="nc" id="L219">        List&lt;EC2InstanceTO&gt; instances = executionStateCache.getInstances();</span>
<span class="nc bnc" id="L220" title="All 4 branches missed.">        if (instances == null || instances.isEmpty()) {</span>
<span class="nc" id="L221">            throw new RuntimeException(&quot;No Instances are vailable&quot;);</span>
        }

<span class="nc bnc" id="L224" title="All 2 branches missed.">        if (cores &lt;= 0) {</span>
<span class="nc" id="L225">            throw new RuntimeException(&quot;Invalid number of cores provided&quot;);</span>
        }

<span class="nc bnc" id="L228" title="All 2 branches missed.">        if (numHosts &gt; instances.size()) {</span>
<span class="nc" id="L229">            numHosts = instances.size();</span>
        }

<span class="nc" id="L232">        List&lt;EC2InstanceTO&gt; instanceList = instances;</span>
<span class="nc bnc" id="L233" title="All 2 branches missed.">        if (instanceList.size() != numHosts) {</span>
<span class="nc" id="L234">            instanceList = instances.subList(0, numHosts);</span>
        }

<span class="nc" id="L237">        List&lt;String&gt; commands = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L238" title="All 2 branches missed.">        for (int i = 0; i &lt; cores; i++) {</span>
<span class="nc" id="L239">            commands.addAll(CommandUtility.getCommandsFromFile(Command.SPIKECPU.getCommandName() + &quot;.txt&quot;));</span>
        }

<span class="nc" id="L242">        String commandId = ssmRaider.executeShellCommands(Ec2Utils.generateInstanceIdList(instanceList), commands);</span>


<span class="nc" id="L245">        executionStateCache.setCpuSpiked(true);</span>
<span class="nc" id="L246">        executionStateCache.setCommandId(commandId);</span>
<span class="nc" id="L247">        executionStateCache.setSsmCommandInvocationInstances(instanceList);</span>

<span class="nc" id="L249">        return this;</span>
    }

    /**
     * Terminates the given process on all available instances.
     *
     * @param processName process name
     * @return the ssm step definitions
     * @throws Throwable the throwable
     */
    @When(&quot;^SSM terminate process \&quot;([^\&quot;]*)\&quot;$&quot;)
    public SSMStepDefinitions terminateProcessOnAllHealthyInstances(String processName) throws Throwable {
<span class="nc" id="L261">        this.executeCommand(executionStateCache.getInstances().size(), Command.KILLPROCESS, processName);</span>
<span class="nc" id="L262">        executionStateCache.addProcessName(processName);</span>
<span class="nc" id="L263">        executionStateCache.setHealProcess(true);</span>

<span class="nc" id="L265">        return this;</span>
    }

    /**
     * Add &quot;size&quot; GB to the specified volume.
     *
     * @param volumeType name of volume
     * @param size size of disk
     * @param instanceID instance id
     * @param instanceIP instance private ip
     */
    @Override
    public void diskFullGivenInstance(String volumeType, int size, String instanceID, String instanceIP) {
<span class="nc" id="L278">        List&lt;String&gt; list = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L279">        list.add(instanceID);</span>

<span class="nc" id="L281">        String commandId = ssmRaider.executeShellCommand(list, Command.DISKFULL, volumeType, String.valueOf(size));</span>
<span class="nc" id="L282">        executionStateCache.setCommandId(commandId);</span>
<span class="nc" id="L283">        executionStateCache.addSsmCommandInvocationInstances(executionStateCache.findEC2InstanceGivenID(instanceID));</span>
<span class="nc" id="L284">    }</span>

    /**
     * Add &quot;size&quot; GB to the specified volume on each instance for the given number of instances.
     *
     * @param volumeType name of volume
     * @param size       size of disk
     * @param numHosts   number of instances
     * @return the ssm step definitions
     * @throws Throwable the throwable
     */
    @When(&quot;^SSM \&quot;([^\&quot;]*)\&quot; disk full with (\\d+) GB on (\\d+) instance$&quot;)
    public SSMStepDefinitions diskFullOnInstance(String volumeType, int size, int numHosts) throws Throwable {

<span class="nc" id="L298">        this.executeCommand(numHosts, Command.DISKFULL, volumeType, String.valueOf(size));</span>
<span class="nc" id="L299">        return this;</span>

    }

    /**
     * Add &quot;size&quot; GB to the RAM on each instance for the given number of instances.
     *
     * @param size     size of disk
     * @param numHosts number of instances
     * @return the ssm step definitions
     * @throws Throwable the throwable
     */
    @When(&quot;^SSM RAM disk full with (\\d+) GB on (\\d+) instance$&quot;)
    public SSMStepDefinitions ramDiskFullOnInstance(int size, int numHosts) throws Throwable {

<span class="nc" id="L314">        this.executeCommand(numHosts, Command.RAMDISKFULL, String.valueOf(size));</span>
<span class="nc" id="L315">        executionStateCache.setRamDiskFull(true);</span>

<span class="nc" id="L317">        return this;</span>

    }

    /**
     * Block the given domain name on the specified number of instances.
     *
     * @param domainName domain name
     * @param numHosts   number of instances
     * @return the ssm step definitions
     */
    @When(&quot;^SSM block domain \&quot;([^\&quot;]*)\&quot; on (\\d+) instances$&quot;)
    public SSMStepDefinitions blockDomain(String domainName, int numHosts) {
<span class="nc" id="L330">        this.executeCommand(numHosts, Command.BLOCKDOMAIN, domainName);</span>
<span class="nc" id="L331">        executionStateCache.getBlockedDomains().add(domainName);</span>
<span class="nc" id="L332">        return this;</span>
    }


    /**
     * Block dynamo db ssm step definitions.
     *
     * @param numHosts the num hosts
     * @return the ssm step definitions
     */
    @When(&quot;^SSM block DynamoDB on (\\d+) instances$&quot;)
    public SSMStepDefinitions blockDynamoDB( int numHosts)
    {
<span class="nc" id="L345">        this.executeCommand(numHosts, Command.BLOCKDYNAMODB,null);</span>
<span class="nc" id="L346">        executionStateCache.setBlockDynamoDB(true);</span>
<span class="nc" id="L347">        return this;</span>
    }


    /**
     * Block s 3 ssm step definitions.
     *
     * @param numHosts the num hosts
     * @return the ssm step definitions
     */
    @When(&quot;^SSM block S3 on (\\d+) instances$&quot;)
    public SSMStepDefinitions blockS3(int numHosts)
    {
<span class="nc" id="L360">        this.executeCommand(numHosts, Command.BLOCKS3,null);</span>
<span class="nc" id="L361">        executionStateCache.setBlockS3(true);</span>
<span class="nc" id="L362">        return this;</span>
    }

    /**
     * Stop the given process on the specified number of instances.
     *
     * @param serviceOrProcessType service or process (UNUSED)
     * @param processName          process name
     * @param numHosts             number of instances
     * @return the ssm step definitions
     */
    @When(&quot;^SSM stop (service|process) \&quot;([^\&quot;]*)\&quot; on (\\d+) instance$&quot;)
    public SSMStepDefinitions stopProcessOnHealthyInstances(String serviceOrProcessType, String processName, int numHosts) {
<span class="nc" id="L375">        executionStateCache.addProcessName(processName);</span>
<span class="nc" id="L376">        this.executeCommand(numHosts, Command.STOPSERVICE, processName);</span>
<span class="nc" id="L377">        executionStateCache.setHealProcess(true);</span>

<span class="nc" id="L379">        return this;</span>
    }

    /**
     * Start the given process on the specified number of instances.
     *
     * @param serviceOrProcessType service or process (UNUSED)
     * @param processName          process name
     * @param numHosts             number of instances
     * @return the ssm step definitions
     */
    @When(&quot;^SSM start (service|process) \&quot;([^\&quot;]*)\&quot; on (\\d+) instance$&quot;)
    public SSMStepDefinitions startProcessOnHealthyInstances(String serviceOrProcessType, String processName, int numHosts) {

<span class="nc" id="L393">        this.executeCommand(numHosts, Command.STARTSERVICE, processName);</span>
<span class="nc" id="L394">        return this;</span>
    }

    /**
     * Corrupt the given percentage of each instance's traffic for the specified number of instances.
     *
     * @param corruptPercent corruption percentage (0 to 100, inclusive)
     * @param numHosts       number of instances.
     * @return the ssm step definitions
     */
    @When(&quot;^SSM corrupt network (\\d+) percent on (\\d+) instances$&quot;)
    public SSMStepDefinitions corruptNetwork(int corruptPercent, int numHosts) {
<span class="nc" id="L406">        this.executeCommand(numHosts, Command.CORRUPTNETWORK, String.valueOf(corruptPercent));</span>
<span class="nc" id="L407">        executionStateCache.setHealNetwork(true);</span>
<span class="nc" id="L408">        return this;</span>

    }

    /**
     * Injects network latency within the bounds on the default interface.
     *
     * @param lowerBound lower bound for latency
     * @param upperBound upper bound for latency
     * @param instanceID instance id
     * @param instanceIP instance private ip
     */
    @Override
    public void injectNetworkLatencyGivenInstance(int lowerBound, int upperBound, String instanceID, String instanceIP) {
<span class="nc" id="L422">        List&lt;String&gt; list = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L423">        list.add(instanceID);</span>

<span class="nc" id="L425">        String commandId = ssmRaider.executeShellCommand(list, Command.DELAYNETWORK, String.valueOf(lowerBound), String.valueOf(upperBound));</span>
<span class="nc" id="L426">        executionStateCache.setCommandId(commandId);</span>
<span class="nc" id="L427">        executionStateCache.addSsmCommandInvocationInstances(executionStateCache.findEC2InstanceGivenID(instanceID));</span>
<span class="nc" id="L428">        executionStateCache.setHealNetwork(true);</span>
<span class="nc" id="L429">    }</span>

    /**
     * Inject network latency within the bounds on the default interface for the given number of instances.
     *
     * @param lowerBound lower bound for latency
     * @param upperBound upper bound for latency
     * @param numHosts   number of instances
     * @return the ssm step definitions
     */
    @When(&quot;^SSM inject network latency (\\d+) ms to (\\d+) ms on (\\d+) instances$&quot;)
    public SSMStepDefinitions injectNetworkLatency(int lowerBound, int upperBound, int numHosts) {

<span class="nc" id="L442">        this.executeCommand(numHosts, Command.DELAYNETWORK, String.valueOf(lowerBound), String.valueOf(upperBound));</span>
<span class="nc" id="L443">        executionStateCache.setHealNetwork(true);</span>

<span class="nc" id="L445">        return this;</span>

    }

    /**
     * Inject packet loss at the given percentage for the specified number of instances.
     *
     * @param percentLoss percentage of packet loss
     * @param numHosts    number of instances
     * @return the ssm step definitions
     */
    @When(&quot;^SSM inject network packet loss (\\d+) percent on (\\d+) instances$&quot;)
    public SSMStepDefinitions injectPacketLoss(int percentLoss, int numHosts) {
<span class="nc" id="L458">        this.executeCommand(numHosts, Command.PACKETLOSS, String.valueOf(percentLoss));</span>
<span class="nc" id="L459">        executionStateCache.setHealNetwork(true);</span>
<span class="nc" id="L460">        return this;</span>
    }

    /**
     * Block traffic on the given port number.
     *
     * @param portNum port number to block
     * @param instanceID instance id
     * @param instanceIP instance private ip
     */
    @Override
    public void blockPortGivenInstance(int portNum, String instanceID, String instanceIP) {
<span class="nc" id="L472">        List&lt;String&gt; list = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L473">        list.add(instanceID);</span>

<span class="nc" id="L475">        String commandId = ssmRaider.executeShellCommand(list, Command.BLOCKPORT, String.valueOf(portNum));</span>
<span class="nc" id="L476">        executionStateCache.addSsmCommandInvocationInstances(executionStateCache.findEC2InstanceGivenID(instanceID));</span>
<span class="nc" id="L477">        executionStateCache.setCommandId(commandId);</span>
<span class="nc" id="L478">        executionStateCache.setBlockPort(true);</span>
<span class="nc" id="L479">        executionStateCache.addPortNum(portNum);</span>
<span class="nc" id="L480">    }</span>

    /**
     * Block the given port number on the specified number of instances.
     *
     * @param portNum  port number
     * @param numHosts number of instances
     * @return the ssm step definitions
     */
    @When(&quot;^SSM block network port (\\d+) on (\\d+) instances$&quot;)
    public SSMStepDefinitions blockPort(int portNum, int numHosts) {
<span class="nc" id="L491">        this.executeCommand(numHosts, Command.BLOCKPORT, String.valueOf(portNum));</span>
<span class="nc" id="L492">        executionStateCache.setBlockPort(true);</span>
<span class="nc" id="L493">        executionStateCache.addPortNum(portNum);</span>
<span class="nc" id="L494">        return this;</span>
    }

    /**
     * Block outgoing traffic for the given port number on the specified number of instances
     *
     * @param portNum  port number
     * @param numHosts number of instances
     * @return the ssm step definitions
     */
    @When(&quot;^SSM block outbound network port (\\d+) on (\\d+) instances$&quot;)
    public SSMStepDefinitions blockOutboundPort(int portNum, int numHosts) {
<span class="nc" id="L506">        this.executeCommand(numHosts, Command.BLOCKOUTBOUNDPORT, String.valueOf(portNum));</span>
<span class="nc" id="L507">        executionStateCache.setBlockPort(true);</span>
<span class="nc" id="L508">        executionStateCache.addPortNum(portNum);</span>
<span class="nc" id="L509">        return this;</span>
    }

    /**
     * Executes the provided command with its parameters on the specified number of instances.
     *
     * @param numHosts number of instances
     * @param command command to execute
     * @param params parameters (multiple parameters allowed)
     */
    private void executeCommand(int numHosts, Command command, String... params) {
<span class="nc" id="L520">        List&lt;EC2InstanceTO&gt; instances = executionStateCache.getInstances();</span>

<span class="nc bnc" id="L522" title="All 4 branches missed.">        if (instances == null || instances.isEmpty()) {</span>
<span class="nc" id="L523">            throw new RuntimeException(&quot;No Instances are vailable&quot;);</span>
        }

<span class="nc bnc" id="L526" title="All 2 branches missed.">        if (numHosts &gt; instances.size()) {</span>
<span class="nc" id="L527">            numHosts = instances.size();</span>
        }

<span class="nc" id="L530">        List&lt;EC2InstanceTO&gt; instanceList = instances;</span>
<span class="nc bnc" id="L531" title="All 2 branches missed.">        if (instanceList.size() != numHosts) {</span>
<span class="nc" id="L532">            instanceList = instances.subList(0, numHosts);</span>
        }

<span class="nc" id="L535">        String commandId = ssmRaider.executeShellCommand(Ec2Utils.generateInstanceIdList(instanceList), command, params);</span>

<span class="nc" id="L537">        executionStateCache.setCommandId(commandId);</span>
<span class="nc" id="L538">        executionStateCache.setSsmCommandInvocationInstances(instanceList);</span>
<span class="nc" id="L539">    }</span>

    /**
     * Finds the provided number of instances to run commands on.
     *
     * @param numHosts number of instances to execute on
     * @return list of instances to execute on
     */
    private List&lt;EC2InstanceTO&gt; getInstancesForExecution(int numHosts) {

<span class="nc" id="L549">        List&lt;EC2InstanceTO&gt; instances = executionStateCache.getInstances();</span>

<span class="nc bnc" id="L551" title="All 4 branches missed.">        if (instances == null || instances.isEmpty()) {</span>
<span class="nc" id="L552">            throw new RuntimeException(&quot;No Instances are available&quot;);</span>
        }

<span class="nc bnc" id="L555" title="All 2 branches missed.">        if (numHosts &gt; instances.size()) {</span>
<span class="nc" id="L556">            numHosts = instances.size();</span>
        }

<span class="nc" id="L559">        List&lt;EC2InstanceTO&gt; instanceList = instances;</span>
<span class="nc bnc" id="L560" title="All 2 branches missed.">        if (instanceList.size() != numHosts) {</span>
<span class="nc" id="L561">            instanceList = instances.subList(0, numHosts);</span>
        }

<span class="nc" id="L564">        return instanceList;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.3.201901230119</span></div></body></html>