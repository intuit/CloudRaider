<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>InstanceFailureStepDefinitions.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">cloudraider-core</a> &gt; <a href="index.source.html" class="el_package">com.intuit.cloudraider.cucumber.steps</a> &gt; <span class="el_source">InstanceFailureStepDefinitions.java</span></div><h1>InstanceFailureStepDefinitions.java</h1><pre class="source lang-java linenums">/*
 * Apache 2.0 License
 *
 * Copyright (c) 2019 Intuit Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the &quot;Software&quot;), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

package com.intuit.cloudraider.cucumber.steps;


import com.amazonaws.services.ec2.model.Tag;
import com.intuit.cloudraider.core.interfaces.EC2Raider;
import com.intuit.cloudraider.cucumber.interfaces.EC2StepFunctions;
import com.intuit.cloudraider.cucumber.model.ExecutionStateCache;
import com.intuit.cloudraider.cucumber.util.CucumberHelperFunctions;
import com.intuit.cloudraider.cucumber.util.ScriptExecutor;
import com.intuit.cloudraider.model.EC2InstanceTO;
import cucumber.api.java.en.Given;
import cucumber.api.java.en.Then;
import cucumber.api.java.en.When;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.stream.IntStream;

/**
 * Cucumber Step Definitions for AWS EC2 functionality.
 */
public class InstanceFailureStepDefinitions implements EC2StepFunctions {

    @Autowired
    @Qualifier(&quot;scriptExecutor&quot;)
    private ScriptExecutor scriptExecutor;

    @Autowired
    @Qualifier(&quot;ec2raiderBean&quot;)
    private EC2Raider ec2Raider;

    /**
     * The Logger.
     */
<span class="nc" id="L64">    Logger logger = LoggerFactory.getLogger(this.getClass());</span>

    private static final String MULTIPLE_DELIMITER = &quot;,&quot;;

    /**
     * Gets execution state cache.
     *
     * @return the execution state cache
     */
    public ExecutionStateCache getExecutionStateCache() {
<span class="nc" id="L74">        return executionStateCache;</span>
    }

    public void setExecutionStateCache(ExecutionStateCache executionStateCache) {
<span class="nc" id="L78">        this.executionStateCache = executionStateCache;</span>
<span class="nc" id="L79">    }</span>

    @Autowired
    private ExecutionStateCache executionStateCache;

    /**
     * Instantiates a new Instance failure step definitions.
     */
<span class="nc" id="L87">    public InstanceFailureStepDefinitions() {</span>
<span class="nc" id="L88">    }</span>

    /**
     * Finds EC2 instances with the given name and adds to execution cache.
     *
     * @param name name of instance
     * @return the instance failure step definitions
     */
    @Given(&quot;^EC2 \&quot;([^\&quot;]*)\&quot;$&quot;)
    public InstanceFailureStepDefinitions givenEC2InstanceName(String name) {
<span class="nc" id="L98">        executionStateCache.addInstances(findInstancesByName(name));</span>
<span class="nc" id="L99">        executionStateCache.setEc2Tag(name);</span>
<span class="nc" id="L100">        return this;</span>
    }

    /**
     * Finds EC2 instances with the given tag and adds to execution cache.
     *
     * @param tag tag in the form &quot;key:value&quot;
     * @return the instance failure step definitions
     */
    @Given(&quot;^EC2 with a tag \&quot;([^\&quot;]*)\&quot;$&quot;)
    public InstanceFailureStepDefinitions givenEC2InstanceTags(String tag) {
<span class="nc" id="L111">        executionStateCache.addInstances(findAllInstancesByTag(tag));</span>
<span class="nc" id="L112">        executionStateCache.setEc2Tag(tag);</span>
<span class="nc" id="L113">        return this;</span>
    }

    /**
     * Finds EC2 instances with names that do not include the provided keywords and adds to execution cache.
     *
     * @param filters keywords to ignore in the name, separated by &quot;,&quot; (comma)
     * @return the instance failure step definitions
     */
    @Given(&quot;^EC2 instances filtered by \&quot;([^\&quot;]*)\&quot;$&quot;)
    public InstanceFailureStepDefinitions givenFilteredEC2(String filters) {
<span class="nc" id="L124">        List&lt;String&gt; filtersList = Arrays.asList(filters.split(&quot;\\s*&quot; + MULTIPLE_DELIMITER + &quot;\\s*&quot;));</span>
<span class="nc" id="L125">        executionStateCache.setInstances(ec2Raider.getFilteredActiveInstances(filtersList));</span>
<span class="nc" id="L126">        return this;</span>
    }

    /**
     * FindsEC2 instances with any of the given tags and adds to execution cache.
     *
     * @param tags tags in the form &quot;key:value&quot;,&quot;key:value&quot;
     * @return the instance failure step definitions
     */
    @Given(&quot;^EC2 with a tags \&quot;([^\&quot;]*)\&quot;$&quot;)
    public InstanceFailureStepDefinitions givenEC2InstanceTags(String... tags) {
<span class="nc" id="L137">        List&lt;String&gt; tagsList = Arrays.asList(tags);</span>
<span class="nc" id="L138">        tagsList.parallelStream().forEach(</span>
<span class="nc" id="L139">                t -&gt; executionStateCache.addInstances(findAllInstancesByTag(t))</span>
        );
<span class="nc" id="L141">        return this;</span>
    }

    /**
     * Terminate the given process on the instance.
     *
     * @param processName process name
     * @param instanceID instance id
     * @param instanceIP instance private ip
     */
    public void terminateProcessGivenInstance(String processName, String instanceID, String instanceIP) {
<span class="nc" id="L152">        terminateProcessGivenInstanceCucumber(processName, instanceID, instanceIP);</span>
<span class="nc" id="L153">    }</span>

    /**
     * Terminate the given process on all available instances.
     *
     * @param processName process name
     * @return the instance failure step definitions
     * @throws Throwable the throwable
     */
    @When(&quot;^terminate process \&quot;([^\&quot;]*)\&quot;$&quot;)
    public InstanceFailureStepDefinitions terminateProcessOnAllHealthyInstances(String processName) throws Throwable {
<span class="nc" id="L164">        List&lt;EC2InstanceTO&gt; instances = executionStateCache.getInstances();</span>
<span class="nc bnc" id="L165" title="All 4 branches missed.">        if (instances == null || instances.isEmpty()) {</span>
<span class="nc" id="L166">            throw new RuntimeException(&quot;No Instances are available&quot;);</span>
        }
<span class="nc" id="L168">        executionStateCache.addProcessName(processName);</span>

<span class="nc" id="L170">        terminateProcess(processName, instances.size(), instances);</span>

<span class="nc" id="L172">        return this;</span>
    }

    /**
     * Terminate the given process on the instance.
     *
     * @param processName process name
     * @param instanceID  instance id
     * @param instanceIP  instance private ip
     * @return the instance failure step definitions
     */
    @When(&quot;^terminate process \&quot;([^\&quot;]*)\&quot; on instance with id \&quot;([^\&quot;]*)\&quot; and ip \&quot;([^\&quot;]*)\&quot;$&quot;)
    public InstanceFailureStepDefinitions terminateProcessGivenInstanceCucumber(String processName, String instanceID, String instanceIP) {
<span class="nc" id="L185">        List&lt;EC2InstanceTO&gt; instances = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L186">        instances.add(executionStateCache.findEC2InstanceGivenID(instanceID));</span>

<span class="nc" id="L188">        executionStateCache.addProcessName(processName);</span>

<span class="nc" id="L190">        terminateProcess(processName, 1, instances);</span>

<span class="nc" id="L192">        return this;</span>
    }

    /**
     * Terminate the given process on the provided number of instances.
     *
     * @param processName process name
     * @param numHosts    number of instances
     * @return the instance failure step definitions
     */
    @When(&quot;^terminate process  \&quot;([^\&quot;]*)\&quot; on (\\d+) instance$&quot;)
    public InstanceFailureStepDefinitions terminateProcessOnHealthyInstances(String processName, int numHosts) {
<span class="nc" id="L204">        List&lt;EC2InstanceTO&gt; instances = executionStateCache.getInstances();</span>

<span class="nc bnc" id="L206" title="All 4 branches missed.">        if (instances == null || instances.isEmpty()) {</span>
<span class="nc" id="L207">            throw new RuntimeException(&quot;No Instances are available&quot;);</span>
        }

<span class="nc" id="L210">        executionStateCache.addProcessName(processName);</span>

<span class="nc bnc" id="L212" title="All 2 branches missed.">        if (numHosts &gt; instances.size()) {</span>
<span class="nc" id="L213">            numHosts = instances.size();</span>
        }

<span class="nc" id="L216">        terminateProcess(processName, numHosts, instances);</span>

<span class="nc" id="L218">        return this;</span>
    }

    /**
     * Terminate the given process on the provided number of instances for the specified availability zone.
     *
     * @param processName process name
     * @param numHosts    number of instances
     * @param zoneId      availability zone id
     * @return the instance failure step definitions
     */
    @When(&quot;^terminate process  \&quot;([^\&quot;]*)\&quot; on (\\d+) instance in zone \&quot;([^\&quot;]*)\&quot;$&quot;)
    public InstanceFailureStepDefinitions terminateProcessInAvailabilityZone(String processName, int numHosts, String zoneId) {
<span class="nc" id="L231">        List&lt;EC2InstanceTO&gt; instancesTO = ec2Raider.getEc2InstancesForAvailabilityZone(zoneId, new ArrayList&lt;&gt;());</span>

<span class="nc bnc" id="L233" title="All 4 branches missed.">        if (instancesTO == null || instancesTO.isEmpty()) {</span>
<span class="nc" id="L234">            throw new RuntimeException(&quot;No Instances are available&quot;);</span>
        }

<span class="nc" id="L237">        executionStateCache.addProcessName(processName);</span>

<span class="nc bnc" id="L239" title="All 2 branches missed.">        if (numHosts &gt; instancesTO.size()) {</span>
<span class="nc" id="L240">            numHosts = instancesTO.size();</span>
        }

<span class="nc" id="L243">        terminateProcess(processName, numHosts, instancesTO);</span>

<span class="nc" id="L245">        return this;</span>
    }

    /**
     * Spike the given number of cores on the instance.
     *
     * @param cores number of cores
     * @param instanceID instance id
     * @param instanceIP instance private ip
     */
    public void spikeCPUGivenInstance(int cores, String instanceID, String instanceIP) {
<span class="nc" id="L256">        spikeCPUGivenInstanceCucumber(cores, instanceID, instanceIP);</span>
<span class="nc" id="L257">    }</span>

    /**
     * Spike the given number of cores on the instance.
     *
     * @param cores      number of cores
     * @param instanceID instance id
     * @param instanceIP instance private ip
     * @return the instance failure step definitions
     */
    @When(&quot;^CPU spike for (\\d+) cores on instance with id \&quot;([^\&quot;]*)\&quot; and ip \&quot;([^\&quot;]*)\&quot;$&quot;)
    public InstanceFailureStepDefinitions spikeCPUGivenInstanceCucumber(int cores, String instanceID, String instanceIP) {
<span class="nc" id="L269">        spikeCPUHelper(cores, instanceID, instanceIP);</span>
<span class="nc" id="L270">        executionStateCache.setCpuSpiked(true);</span>
<span class="nc" id="L271">        executionStateCache.addUnHealthyInstance(executionStateCache.findEC2InstanceGivenID(instanceID));</span>
<span class="nc" id="L272">        return this;</span>
    }

    /**
     * Helper function to spike the cores on the instance.
     *
     * @param cores number of cores
     * @param instanceID instance id
     * @param instanceIP instance private ip
     */
    private void spikeCPUHelper(int cores, String instanceID, String instanceIP) {
<span class="nc" id="L283">        logger.info(&quot;starting cpu spike on: &quot; + instanceID + &quot; @ &quot; + instanceIP);</span>
<span class="nc" id="L284">        scriptExecutor.executeCPUSpike(instanceIP, cores);</span>
<span class="nc" id="L285">    }</span>

    /**
     * Spike the given number of cores on the provided number of instances.
     *
     * @param numHosts number of instances
     * @param cores    number of cores
     * @return the instance failure step definitions
     */
    @When(&quot;^CPU spike on (\\d+) instances for (\\d+) cores$&quot;)
    public InstanceFailureStepDefinitions spikeCPUOnHealthyInstances(int numHosts, int cores) {
<span class="nc" id="L296">        List&lt;EC2InstanceTO&gt; instances = executionStateCache.getInstances();</span>
<span class="nc bnc" id="L297" title="All 4 branches missed.">        if (instances == null || instances.isEmpty()) {</span>
<span class="nc" id="L298">            throw new RuntimeException(&quot;No Instances are available&quot;);</span>
        }

<span class="nc bnc" id="L301" title="All 2 branches missed.">        if (numHosts &gt; instances.size()) {</span>
<span class="nc" id="L302">            numHosts = instances.size();</span>
        }

<span class="nc" id="L305">        IntStream.range(0, numHosts)</span>
<span class="nc" id="L306">                .parallel()</span>
<span class="nc" id="L307">                .forEach(</span>
                        i -&gt;
                        {
<span class="nc" id="L310">                            spikeCPUHelper(cores, instances.get(i).getInstanceId(), instances.get(i).getPrivateIpAddress());</span>
<span class="nc" id="L311">                            executionStateCache.addUnHealthyInstance(instances.get(i));</span>
<span class="nc" id="L312">                            executionStateCache.setCpuSpiked(true);</span>
<span class="nc" id="L313">                        });</span>

<span class="nc" id="L315">        return this;</span>
    }

    /**
     * Terminate all available EC2 instances.
     *
     * @return the instance failure step definitions
     */
    @When(&quot;^terminate all instances$&quot;)
    public InstanceFailureStepDefinitions terminateAllInstances() {
<span class="nc" id="L325">        List&lt;EC2InstanceTO&gt; instances = executionStateCache.getInstances();</span>
<span class="nc bnc" id="L326" title="All 4 branches missed.">        if (instances == null || instances.isEmpty()) {</span>
<span class="nc" id="L327">            throw new RuntimeException(&quot;No Instances are available&quot;);</span>
        }

<span class="nc" id="L330">        instances.parallelStream()</span>
<span class="nc" id="L331">                .forEach(i -&gt;  {</span>
<span class="nc" id="L332">                    terminationHelper(i.getInstanceId(), i.getPrivateIpAddress());</span>
<span class="nc" id="L333">                });</span>

<span class="nc" id="L335">        return this;</span>
    }

    /**
     * Terminates the provided instance.
     *
     * @param instanceID instance id
     * @param instanceIP instance private ip
     */
    public void terminateGivenInstance(String instanceID, String instanceIP) {
<span class="nc" id="L345">        terminateGivenInstanceCucumber(instanceID, instanceIP);</span>
<span class="nc" id="L346">    }</span>

    /**
     * Helper function for terminating provided instance.
     *
     * @param instanceID instance id
     * @param instanceIP instance private ip
     */
    private void terminationHelper(String instanceID, String instanceIP) {
<span class="nc" id="L355">        logger.info(&quot;Terminating instance: &quot; + instanceID + &quot; @ &quot; + instanceIP);</span>
<span class="nc" id="L356">        ec2Raider.terminateEc2InstancesById(instanceID);</span>
<span class="nc" id="L357">    }</span>

    /**
     * Terminates the provided instance.
     *
     * @param instanceID instance id
     * @param instanceIP instance private ip
     * @return the instance failure step definitions
     */
    @When(&quot;^terminate instance with id \&quot;([^\&quot;]*)\&quot; and ip \&quot;([^\&quot;]*)\&quot;$&quot;)
    public InstanceFailureStepDefinitions terminateGivenInstanceCucumber(String instanceID, String instanceIP) {
<span class="nc" id="L368">        terminationHelper(instanceID, instanceIP);</span>
<span class="nc" id="L369">        return this;</span>
    }

    /**
     * Terminates the given number of instances.
     *
     * @param numInstances number of instances
     * @return the instance failure step definitions
     */
    @When(&quot;^terminate (\\d+) instance$&quot;)
    public InstanceFailureStepDefinitions terminateInstanceOnNumInstances(int numInstances) {
<span class="nc" id="L380">        List&lt;EC2InstanceTO&gt; instances = executionStateCache.getInstances();</span>
<span class="nc bnc" id="L381" title="All 4 branches missed.">        if (instances == null || instances.isEmpty()) {</span>
<span class="nc" id="L382">            throw new RuntimeException(&quot;Unable to terminate process, no instances available&quot;);</span>
        }

<span class="nc bnc" id="L385" title="All 2 branches missed.">        if (numInstances &gt; instances.size()) {</span>
<span class="nc" id="L386">            numInstances = instances.size();</span>
        }

<span class="nc" id="L389">        IntStream.range(0, numInstances)</span>
<span class="nc" id="L390">                .parallel()</span>
<span class="nc" id="L391">                .forEach(</span>
                        i -&gt;
                        {
<span class="nc" id="L394">                            terminationHelper(instances.get(i).getInstanceId(), instances.get(i).getPrivateIpAddress());</span>
<span class="nc" id="L395">                        });</span>

<span class="nc" id="L397">        return this;</span>
    }

    /**
     * Terminates the given number of instances with matching tags. The instance must have all tags in order to be considered.
     *
     * @param numInstances         number of instances
     * @param compulsoryTagsString tags in the form of &quot;key:value,key:value&quot;
     * @return the instance failure step definitions
     */
    @When(&quot;^terminate (\\d+) instance with tags \&quot;([^\&quot;]*)\&quot;$&quot;)
    public InstanceFailureStepDefinitions terminateInstanceOnNumInstancesWithTags(int numInstances, String compulsoryTagsString) {
<span class="nc" id="L409">        List&lt;Tag&gt; compulsoryTags = CucumberHelperFunctions.tagStringToList(compulsoryTagsString);</span>

<span class="nc" id="L411">        List&lt;EC2InstanceTO&gt; instances = executionStateCache.getInstances();</span>

<span class="nc bnc" id="L413" title="All 4 branches missed.">        if (instances == null || instances.isEmpty()) {</span>
<span class="nc" id="L414">            throw new RuntimeException(&quot;Unable to terminate process, no instances available in AZ&quot;);</span>
        }

<span class="nc bnc" id="L417" title="All 2 branches missed.">        if (numInstances &gt; instances.size()) {</span>
<span class="nc" id="L418">            numInstances = instances.size();</span>
        }

<span class="nc" id="L421">        int terminatedInstances = 0;</span>
<span class="nc bnc" id="L422" title="All 2 branches missed.">        for (EC2InstanceTO instance : instances) {</span>
<span class="nc" id="L423">            boolean flag = CucumberHelperFunctions.containsAllCompulsoryTags(compulsoryTags, instance.getTags());</span>

<span class="nc bnc" id="L425" title="All 2 branches missed.">            if (flag) {</span>
<span class="nc" id="L426">                ec2Raider.terminateEc2InstancesById(instance.getInstanceId());</span>
<span class="nc" id="L427">                terminatedInstances++;</span>
            }

<span class="nc bnc" id="L430" title="All 2 branches missed.">            if (terminatedInstances == numInstances) {</span>
<span class="nc" id="L431">                break;</span>
            }

<span class="nc" id="L434">        }</span>
<span class="nc" id="L435">        return this;</span>
    }

    /**
     * Stops the given number of available instances.
     *
     * @param numInstances number of instances
     * @return the instance failure step definitions
     */
    @When(&quot;^stop (\\d+) instance$&quot;)
    public InstanceFailureStepDefinitions stopInstanceOnNumInstances(int numInstances ) {
<span class="nc" id="L446">        List&lt;EC2InstanceTO&gt; stoppedInstances = executionStateCache.getStoppedInstances();</span>

<span class="nc" id="L448">        List&lt;EC2InstanceTO&gt; instances = executionStateCache.getInstances();</span>
<span class="nc bnc" id="L449" title="All 4 branches missed.">        if (instances == null  || instances.isEmpty()) {</span>
<span class="nc" id="L450">            throw new RuntimeException(&quot;Unable to stop, no instances available&quot;);</span>
        }

<span class="nc bnc" id="L453" title="All 2 branches missed.">        if (numInstances &gt; instances.size()) {</span>
<span class="nc" id="L454">            numInstances = instances.size();</span>
        }

<span class="nc" id="L457">        IntStream.range(0, numInstances)</span>
<span class="nc" id="L458">                .parallel()</span>
<span class="nc" id="L459">                .forEach(</span>
                        i -&gt;
                        {
<span class="nc" id="L462">                            ec2Raider.stopEc2Instances(instances.get(i).getInstanceId());</span>
<span class="nc" id="L463">                            stoppedInstances.add(instances.get(i));</span>
<span class="nc" id="L464">                        } );</span>

<span class="nc" id="L466">        executionStateCache.setStoppedInstances(stoppedInstances);</span>

<span class="nc" id="L468">        return this;</span>
    }

    /**
     * Restarts the given number of stopped instances.
     *
     * @param numInstances number of instances
     * @return the instance failure step definitions
     */
    @Then(&quot;^start (\\d+) instance$&quot;)
    public InstanceFailureStepDefinitions startInstanceOnNumInstances(int numInstances ) {
<span class="nc" id="L479">        List&lt;EC2InstanceTO&gt; stoppedInstances = executionStateCache.getStoppedInstances();</span>
<span class="nc" id="L480">        List&lt;EC2InstanceTO&gt; restartedInstances = new ArrayList&lt;&gt;();</span>

<span class="nc bnc" id="L482" title="All 4 branches missed.">        if (stoppedInstances == null  || stoppedInstances.isEmpty()) {</span>
<span class="nc" id="L483">            logger.debug(&quot;EC2RaiderStepDefinitions - All instances are active&quot;);</span>
<span class="nc" id="L484">            return this;</span>
        }

<span class="nc bnc" id="L487" title="All 2 branches missed.">        if (numInstances &gt; stoppedInstances.size()) {</span>
<span class="nc" id="L488">            numInstances = stoppedInstances.size();</span>
        }

<span class="nc" id="L491">        IntStream.range(0, numInstances)</span>
<span class="nc" id="L492">                .parallel()</span>
<span class="nc" id="L493">                .forEach(</span>
                        i -&gt;
                        {
<span class="nc" id="L496">                            restartedInstances.add(stoppedInstances.get(i));</span>
<span class="nc" id="L497">                            ec2Raider.restartEc2Instances(stoppedInstances.get(i).getInstanceId());</span>
<span class="nc" id="L498">                        } );</span>

<span class="nc" id="L500">        stoppedInstances.removeAll(restartedInstances);</span>
<span class="nc" id="L501">        executionStateCache.setStoppedInstances(stoppedInstances);</span>

<span class="nc" id="L503">        return this;</span>
    }


    /**
     * Add &quot;size&quot; GB to the specified volume.
     *
     * @param volumeType name of volume
     * @param size size of disk
     * @param instanceID instance id
     * @param instanceIP instance private ip
     */
    public void diskFullGivenInstance(String volumeType, int size, String instanceID, String instanceIP) {
<span class="nc" id="L516">        diskFullGivenInstanceCucumber(volumeType, size, instanceID, instanceIP);</span>
<span class="nc" id="L517">    }</span>

    /**
     * Add &quot;size&quot; GB to the specified volume.
     *
     * @param volumeType name of volume
     * @param size       size of disk
     * @param instanceID instance id
     * @param instanceIP instance private ip
     * @return the instance failure step definitions
     */
    @When(&quot;^\&quot;([^\&quot;]*)\&quot; disk full with (\\d+) GB on instance with id \&quot;([^\&quot;]*)\&quot; and ip \&quot;([^\&quot;]*)\&quot;$&quot;)
    public InstanceFailureStepDefinitions diskFullGivenInstanceCucumber(String volumeType, int size, String instanceID, String instanceIP) {
<span class="nc" id="L530">        diskFullHelper(volumeType, size, instanceID, instanceIP);</span>
<span class="nc" id="L531">        executionStateCache.setHealProcess(true);</span>
<span class="nc" id="L532">        executionStateCache.addUnHealthyInstance(executionStateCache.findEC2InstanceGivenID(instanceID));</span>
<span class="nc" id="L533">        return this;</span>
    }

    /**
     * Helper function to add data to the disk.
     *
     * @param volumeType name of volume
     * @param size size of disk
     * @param instanceID instance id
     * @param instanceIP instance private ip
     */
    private void diskFullHelper(String volumeType, int size, String instanceID, String instanceIP) {
<span class="nc" id="L545">        logger.info(&quot;starting disk full on: &quot; + instanceID + &quot; @ &quot; + instanceIP);</span>
<span class="nc" id="L546">        scriptExecutor.executeDiskFull(instanceIP, volumeType, size);</span>
<span class="nc" id="L547">    }</span>

    /**
     * Add &quot;size&quot; GB to the specified volume on the given number of instances.
     *
     * @param volumeType    name of volume
     * @param size          size of disk
     * @param instanceCount number of instances
     * @return the instance failure step definitions
     * @throws Throwable the throwable
     */
    @When(&quot;^\&quot;([^\&quot;]*)\&quot; disk full with (\\d+) GB on (\\d+) instance$&quot;)
    public InstanceFailureStepDefinitions diskFullOnInstance(String volumeType, int size, int instanceCount) throws Throwable {
<span class="nc" id="L560">        List&lt;EC2InstanceTO&gt; instances = executionStateCache.getInstances();</span>
<span class="nc bnc" id="L561" title="All 4 branches missed.">        if (instances == null || instances.isEmpty()) {</span>
<span class="nc" id="L562">            throw new RuntimeException(&quot;No Instances are available&quot;);</span>
        }

<span class="nc bnc" id="L565" title="All 2 branches missed.">        if (instanceCount &gt; instances.size()) {</span>
<span class="nc" id="L566">            instanceCount = instances.size();</span>
        }


<span class="nc" id="L570">        IntStream.range(0, instanceCount)</span>
<span class="nc" id="L571">                .parallel()</span>
<span class="nc" id="L572">                .forEach(</span>
                        i -&gt;
                        {

<span class="nc" id="L576">                            diskFullHelper(volumeType, size, instances.get(i).getInstanceId(), instances.get(i).getPrivateIpAddress());</span>
<span class="nc" id="L577">                            executionStateCache.setHealProcess(true);</span>
<span class="nc" id="L578">                            executionStateCache.addUnHealthyInstance(instances.get(i));</span>
<span class="nc" id="L579">                        });</span>

<span class="nc" id="L581">        return this;</span>
    }

    /**
     * Block the domain from access on the given number of instances.
     *
     * @param domainName   domain name
     * @param numInstances number of instances
     * @return the instance failure step definitions
     */
    @When(&quot;^block domain \&quot;([^\&quot;]*)\&quot; on (\\d+) instances$&quot;)
    public InstanceFailureStepDefinitions blockDomain(String domainName, int numInstances) {
<span class="nc" id="L593">        List&lt;EC2InstanceTO&gt; instances = executionStateCache.getInstances();</span>
<span class="nc bnc" id="L594" title="All 4 branches missed.">        if (instances == null || instances.isEmpty()) {</span>
<span class="nc" id="L595">            throw new RuntimeException(&quot;No Instances are available&quot;);</span>
        }

<span class="nc bnc" id="L598" title="All 2 branches missed.">        if (numInstances &gt; instances.size()) {</span>
<span class="nc" id="L599">            numInstances = instances.size();</span>
        }

<span class="nc" id="L602">        IntStream.range(0, numInstances )</span>
<span class="nc" id="L603">                .parallel()</span>
<span class="nc" id="L604">                .forEach(</span>
                        i -&gt;
                        {
<span class="nc" id="L607">                            EC2InstanceTO ec2Instance = ec2Raider.getEC2InstanceById(instances.get(i).getInstanceId());</span>
<span class="nc" id="L608">                            String ip = ec2Instance.getPrivateIpAddress();</span>
<span class="nc" id="L609">                            String id = ec2Instance.getInstanceId();</span>
<span class="nc" id="L610">                            logger.info(&quot;blocking domain &quot; + domainName + &quot; on: &quot; + id + &quot; @ &quot; + ip);</span>
<span class="nc" id="L611">                            scriptExecutor.executeBlockDomain(ip, domainName);</span>
<span class="nc" id="L612">                            executionStateCache.getBlockedDomains().add(domainName);</span>
<span class="nc" id="L613">                            executionStateCache.addUnHealthyInstance(ec2Instance);</span>
<span class="nc" id="L614">                        });</span>

<span class="nc" id="L616">        return this;</span>
    }

    /**
     * Block traffic on the given port number.
     *
     * @param portNum port number to block
     * @param instanceID instance id
     * @param instanceIP instance private ip
     */
    public void blockPortGivenInstance(int portNum, String instanceID, String instanceIP) {
<span class="nc" id="L627">        blockPortGivenInstanceCucumber(portNum, instanceID, instanceIP);</span>
<span class="nc" id="L628">    }</span>

    /**
     * Block traffic on the given port number.
     *
     * @param portNum    port number to block
     * @param instanceID instance id
     * @param instanceIP instance private ip
     * @return the instance failure step definitions
     */
    @When(&quot;^block port (\\d+) on instance with id \&quot;([^\&quot;]*)\&quot; and ip \&quot;([^\&quot;]*)\&quot;$&quot;)
    public InstanceFailureStepDefinitions blockPortGivenInstanceCucumber(int portNum, String instanceID, String instanceIP) {
<span class="nc" id="L640">        blockPortHelper(portNum, instanceID, instanceIP);</span>
<span class="nc" id="L641">        executionStateCache.setBlockPort(true);</span>
<span class="nc" id="L642">        executionStateCache.addPortNum(portNum);</span>
<span class="nc" id="L643">        executionStateCache.addUnHealthyInstance(executionStateCache.findEC2InstanceGivenID(instanceID));</span>
<span class="nc" id="L644">        return this;</span>
    }

    /**
     * Helper function to block traffic port.
     *
     * @param portNum port number to block
     * @param instanceID instance id
     * @param instanceIP instance private ip
     */
    private void blockPortHelper(int portNum, String instanceID, String instanceIP) {
<span class="nc" id="L655">        logger.info(&quot;blocking port &quot; + portNum + &quot; on: &quot; + instanceID + &quot; @ &quot; + instanceIP);</span>
<span class="nc" id="L656">        scriptExecutor.executeBlockDomain(instanceIP, String.valueOf(portNum));</span>
<span class="nc" id="L657">    }</span>

    /**
     * Block traffic on the given port number on each of the provided number of instances.
     *
     * @param portNum      port number to block
     * @param numInstances number of instances
     * @return the instance failure step definitions
     */
    @When(&quot;^block port (\\d+) on (\\d+) instances$&quot;)
    public InstanceFailureStepDefinitions blockPort(int portNum, int numInstances) {
<span class="nc" id="L668">        List&lt;EC2InstanceTO&gt; instances = executionStateCache.getInstances();</span>
<span class="nc bnc" id="L669" title="All 4 branches missed.">        if (instances == null || instances.isEmpty()) {</span>
<span class="nc" id="L670">            throw new RuntimeException(&quot;No Instances are available&quot;);</span>
        }

<span class="nc bnc" id="L673" title="All 2 branches missed.">        if (numInstances &gt; instances.size()) {</span>
<span class="nc" id="L674">            numInstances = instances.size();</span>
        }

<span class="nc" id="L677">        IntStream.range(0, numInstances)</span>
<span class="nc" id="L678">                .parallel()</span>
<span class="nc" id="L679">                .forEach(</span>
                        i -&gt;
                        {
<span class="nc" id="L682">                            blockPortHelper(portNum, instances.get(i).getInstanceId(), instances.get(i).getPrivateIpAddress());</span>
<span class="nc" id="L683">                            executionStateCache.setBlockPort(true);</span>
<span class="nc" id="L684">                            executionStateCache.addPortNum(portNum);</span>
<span class="nc" id="L685">                            executionStateCache.addUnHealthyInstance(instances.get(i));</span>
<span class="nc" id="L686">                        });</span>

<span class="nc" id="L688">        return this;</span>
    }

    /**
     * Block dynamo db instance failure step definitions.
     *
     * @param numInstances the num instances
     * @return the instance failure step definitions
     */
    @When(&quot;^block DynamoDB on (\\d+) instances$&quot;)
    public InstanceFailureStepDefinitions blockDynamoDb(int numInstances) {
<span class="nc" id="L699">        List&lt;EC2InstanceTO&gt; instances = executionStateCache.getInstances();</span>
<span class="nc bnc" id="L700" title="All 4 branches missed.">        if (instances == null || instances.isEmpty()) {</span>
<span class="nc" id="L701">            throw new RuntimeException(&quot;No Instances are vailable&quot;);</span>
        }

<span class="nc bnc" id="L704" title="All 2 branches missed.">        if (numInstances &gt; instances.size()) {</span>
<span class="nc" id="L705">            numInstances = instances.size();</span>
        }

<span class="nc" id="L708">        IntStream.range(0, numInstances)</span>
<span class="nc" id="L709">                .parallel()</span>
<span class="nc" id="L710">                .forEach(</span>
                        i -&gt;
                        {
<span class="nc" id="L713">                            EC2InstanceTO ec2SInstance = ec2Raider.getEC2InstanceById(instances.get(i).getInstanceId());</span>
<span class="nc" id="L714">                            String ip = ec2SInstance.getPrivateIpAddress();</span>
<span class="nc" id="L715">                            scriptExecutor.executeBlockDynamoDB(ip);</span>
<span class="nc" id="L716">                            executionStateCache.setBlockDynamoDB(true);</span>
<span class="nc" id="L717">                            executionStateCache.addUnHealthyInstance(ec2SInstance);</span>
<span class="nc" id="L718">                        });</span>

<span class="nc" id="L720">        return this;</span>
    }


    /**
     * Block s 3 instance failure step definitions.
     *
     * @param numInstances the num instances
     * @return the instance failure step definitions
     */
    @When(&quot;^block S3 on (\\d+) instances$&quot;)
    public InstanceFailureStepDefinitions blockS3(int numInstances) {
<span class="nc" id="L732">        List&lt;EC2InstanceTO&gt; instances = executionStateCache.getInstances();</span>
<span class="nc bnc" id="L733" title="All 4 branches missed.">        if (instances == null || instances.isEmpty()) {</span>
<span class="nc" id="L734">            throw new RuntimeException(&quot;No Instances are vailable&quot;);</span>
        }

<span class="nc bnc" id="L737" title="All 2 branches missed.">        if (numInstances &gt; instances.size()) {</span>
<span class="nc" id="L738">            numInstances = instances.size();</span>
        }

<span class="nc" id="L741">        IntStream.range(0, numInstances)</span>
<span class="nc" id="L742">                .parallel()</span>
<span class="nc" id="L743">                .forEach(</span>
                        i -&gt;
                        {
<span class="nc" id="L746">                            EC2InstanceTO ec2SInstance = ec2Raider.getEC2InstanceById(instances.get(i).getInstanceId());</span>
<span class="nc" id="L747">                            String ip = ec2SInstance.getPrivateIpAddress();</span>
<span class="nc" id="L748">                            scriptExecutor.executeBlockS3(ip);</span>
<span class="nc" id="L749">                            executionStateCache.setBlockS3(true);</span>
<span class="nc" id="L750">                            executionStateCache.addUnHealthyInstance(ec2SInstance);</span>
<span class="nc" id="L751">                        });</span>

<span class="nc" id="L753">        return this;</span>
    }

    /**
     * Stop the given process on the specified number of instances.
     *
     * @param serviceOrProcessType service or process (UNUSED)
     * @param processName          process name
     * @param numHosts             number of instances
     * @return the instance failure step definitions
     */
    @When(&quot;^stop (service|process) \&quot;([^\&quot;]*)\&quot; on (\\d+) instance$&quot;)
    public InstanceFailureStepDefinitions stopProcessOnHealthyInstances(String serviceOrProcessType, String processName, int numHosts) {
<span class="nc" id="L766">        List&lt;EC2InstanceTO&gt; instances = executionStateCache.getInstances();</span>

<span class="nc" id="L768">        List&lt;String&gt; processList = new ArrayList&lt;String&gt;(Arrays.asList(processName.split(&quot;,&quot;)));</span>


<span class="nc bnc" id="L771" title="All 4 branches missed.">        if (instances == null || instances.isEmpty())</span>
        {
<span class="nc" id="L773">            throw new RuntimeException(&quot;No Instances are vailable&quot;);</span>
        }

<span class="nc" id="L776">        executionStateCache.addProcessName(processName);</span>

<span class="nc bnc" id="L778" title="All 2 branches missed.">        if (numHosts &gt; instances.size()) {</span>
<span class="nc" id="L779">            numHosts = instances.size();</span>
        }


<span class="nc bnc" id="L783" title="All 2 branches missed.">        for(String process : processList)</span>
        {
<span class="nc" id="L785">        	logger.info(&quot;stopping process: &quot;+ process + &quot;on &quot; + numHosts + &quot; instances &quot;);</span>
<span class="nc" id="L786">        	stopProcess(process.trim(),numHosts,instances);</span>

<span class="nc" id="L788">        }</span>


<span class="nc" id="L791">        return this;</span>
    }

    /**
     * Start the given process on the specified number of instances.
     *
     * @param serviceOrProcessType service or process (UNUSED)
     * @param processName          process name
     * @param numHosts             number of instances
     * @return the instance failure step definitions
     */
    @When(&quot;^start (service|process) \&quot;([^\&quot;]*)\&quot; on (\\d+) instance$&quot;)
    public InstanceFailureStepDefinitions startProcessOnHealthyInstances(String serviceOrProcessType, String processName, int numHosts) {
<span class="nc" id="L804">        List&lt;EC2InstanceTO&gt; instances = executionStateCache.getInstances();</span>

<span class="nc bnc" id="L806" title="All 4 branches missed.">        if (instances == null || instances.isEmpty()) {</span>
<span class="nc" id="L807">            throw new RuntimeException(&quot;No Instances are available&quot;);</span>
        }

<span class="nc" id="L810">        executionStateCache.addProcessName(processName);</span>

<span class="nc bnc" id="L812" title="All 2 branches missed.">        if (numHosts &gt; instances.size()) {</span>
<span class="nc" id="L813">            numHosts = instances.size();</span>
        }

<span class="nc" id="L816">        IntStream.range(0, numHosts)</span>
<span class="nc" id="L817">                .parallel()</span>
<span class="nc" id="L818">                .forEach(</span>
                        i -&gt;
                        {
<span class="nc" id="L821">                            String ip = instances.get(i).getPrivateIpAddress();</span>
<span class="nc" id="L822">                            String id = instances.get(i).getInstanceId();</span>
<span class="nc" id="L823">                            logger.info(&quot;starting process on: &quot; + id + &quot; @ &quot; + ip);</span>
<span class="nc" id="L824">                            scriptExecutor.executeStartProcess(ip, processName);</span>
<span class="nc" id="L825">                        });</span>
<span class="nc" id="L826">        return this;</span>
    }

    /**
     * Injects network latency within the bounds on the default interface.
     *
     * @param lowerBound lower bound for latency
     * @param upperBound upper bound for latency
     * @param instanceID instance id
     * @param instanceIP instance private ip
     */
    public void injectNetworkLatencyGivenInstance(int lowerBound, int upperBound, String instanceID, String instanceIP) {
<span class="nc" id="L838">        injectNetworkLatencyGivenInstanceCucumber(lowerBound, upperBound, instanceID, instanceIP);</span>
<span class="nc" id="L839">    }</span>

    /**
     * Injects network latency within the bounds on the default interface.
     *
     * @param lowerBound lower bound for latency
     * @param upperBound upper bound for latency
     * @param instanceID instance id
     * @param instanceIP instance private ip
     * @return the instance failure step definitions
     */
    @When(&quot;^inject network latency (\\d+) ms to (\\d+) ms on instance with id \&quot;([^\&quot;]*)\&quot; and ip \&quot;([^\&quot;]*)\&quot;$&quot;)
    public InstanceFailureStepDefinitions injectNetworkLatencyGivenInstanceCucumber(int lowerBound, int upperBound, String instanceID, String instanceIP) {
<span class="nc" id="L852">        injectNetworkLatencyHelper(lowerBound, upperBound, instanceID, instanceIP);</span>
<span class="nc" id="L853">        executionStateCache.setHealNetwork(true);</span>
<span class="nc" id="L854">        executionStateCache.addUnHealthyInstance(executionStateCache.findEC2InstanceGivenID(instanceID));</span>
<span class="nc" id="L855">        return this;</span>
    }

    /**
     * Helper function for injecting network latency.
     *
     * @param lowerBound lower bound for latency
     * @param upperBound upper bound for latency
     * @param instanceID instance id
     * @param instanceIP instance private ip
     */
    private void injectNetworkLatencyHelper(int lowerBound, int upperBound, String instanceID, String instanceIP) {
<span class="nc" id="L867">        logger.info(&quot;injecting latency on: &quot; + instanceID + &quot; @ &quot; + instanceIP);</span>
<span class="nc" id="L868">        scriptExecutor.executeRandomNetworkLatency(instanceIP, String.valueOf(upperBound), String.valueOf(lowerBound));</span>
<span class="nc" id="L869">    }</span>

    /**
     * Injects network latency within the bounds on the default interface on each of the provided number of instances.
     *
     * @param lowerBound   lower bound for latency
     * @param upperBound   upper bound for latency
     * @param numInstances number of instances
     * @return the instance failure step definitions
     */
    @When(&quot;^inject network latency (\\d+) ms to (\\d+) ms on (\\d+) instances$&quot;)
    public InstanceFailureStepDefinitions injectNetworkLatency(int lowerBound, int upperBound, int numInstances) {

<span class="nc" id="L882">        List&lt;EC2InstanceTO&gt; instances = executionStateCache.getInstances();</span>
<span class="nc bnc" id="L883" title="All 4 branches missed.">        if (instances == null || instances.isEmpty()) {</span>
<span class="nc" id="L884">            throw new RuntimeException(&quot;No Instances are available&quot;);</span>
        }

<span class="nc bnc" id="L887" title="All 2 branches missed.">        if (numInstances &gt; instances.size()) {</span>
<span class="nc" id="L888">            numInstances = instances.size();</span>
        }

<span class="nc" id="L891">        IntStream.range(0, numInstances)</span>
<span class="nc" id="L892">                .parallel()</span>
<span class="nc" id="L893">                .forEach(</span>
                        i -&gt;
                        {
<span class="nc" id="L896">                            injectNetworkLatencyHelper(lowerBound, upperBound, instances.get(i).getInstanceId(), instances.get(i).getPrivateIpAddress());</span>
<span class="nc" id="L897">                            executionStateCache.setHealNetwork(true);</span>
<span class="nc" id="L898">                            executionStateCache.addUnHealthyInstance(instances.get(i));</span>
<span class="nc" id="L899">                        });</span>

<span class="nc" id="L901">        return this;</span>
    }

    /**
     * Injects domain latency within the bounds on the default interface on each of the provided number of instances.
     *
     * @param domainName   domain name
     * @param lowerBound   lower bound for latency
     * @param upperBound   upper bound for latency
     * @param numInstances number of instances
     * @return the instance failure step definitions
     */
    @When(&quot;^inject domain network latency \&quot;([^\&quot;]*)\&quot; for (\\d+) ms to (\\d+) ms on (\\d+) instances$&quot;)
    public InstanceFailureStepDefinitions injectNetworkLatency(String domainName, int lowerBound, int upperBound, int numInstances) {

<span class="nc" id="L916">        List&lt;EC2InstanceTO&gt; instances = executionStateCache.getInstances();</span>
<span class="nc bnc" id="L917" title="All 4 branches missed.">        if (instances == null || instances.isEmpty()) {</span>
<span class="nc" id="L918">            throw new RuntimeException(&quot;No Instances are available&quot;);</span>
        }

<span class="nc bnc" id="L921" title="All 2 branches missed.">        if (numInstances &gt; instances.size()) {</span>
<span class="nc" id="L922">            numInstances = instances.size();</span>
        }

<span class="nc" id="L925">        IntStream.range(0, numInstances)</span>
<span class="nc" id="L926">                .parallel()</span>
<span class="nc" id="L927">                .forEach(</span>
                        i -&gt;
                        {
<span class="nc" id="L930">                            String ip = instances.get(i).getPrivateIpAddress();</span>
<span class="nc" id="L931">                            logger.info(&quot;injecting domain latency on ip: &quot; + ip + &quot; for domain &quot; + domainName);</span>
<span class="nc" id="L932">                            scriptExecutor.executeRandomDomainNetworkLatency(ip, String.valueOf(upperBound), String.valueOf(lowerBound), domainName);</span>
<span class="nc" id="L933">                            executionStateCache.setHealNetwork(true);</span>
<span class="nc" id="L934">                            executionStateCache.addUnHealthyInstance(instances.get(i));</span>
<span class="nc" id="L935">                        } );</span>

<span class="nc" id="L937">        return this;</span>
    }

    /**
     * Terminate the process on the given number of provided instances.
     *
     * @param processName process name
     * @param numHosts number of instances
     * @param instances instances to perform action on
     */
    private void terminateProcess(String processName, int numHosts, List&lt;EC2InstanceTO&gt; instances) {
<span class="nc" id="L948">        IntStream.range(0, numHosts )</span>
<span class="nc" id="L949">                .parallel()</span>
<span class="nc" id="L950">                .forEach(</span>
                        i -&gt;
                        {
<span class="nc" id="L953">                            String ip = instances.get(i).getPrivateIpAddress();</span>
<span class="nc" id="L954">                            String id = instances.get(i).getInstanceId();</span>
<span class="nc" id="L955">                            logger.info(&quot;starting process termination on: &quot; + id + &quot; @ &quot; + ip);</span>
<span class="nc" id="L956">                            scriptExecutor.executeProcessTermination(ip, processName);</span>
<span class="nc" id="L957">                            executionStateCache.setHealProcess(true);</span>
<span class="nc" id="L958">                            executionStateCache.addUnHealthyInstance(instances.get(i));</span>
<span class="nc" id="L959">                        });</span>
<span class="nc" id="L960">    }</span>

    


    /**
     * Stop the process on the given number of provided instances.
     *
     * @param processName process name
     * @param numHosts number of instances
     * @param instances instances to perform action on
     */
    private void stopProcess(String processName, int numHosts, List&lt;EC2InstanceTO&gt; instances) {
<span class="nc" id="L973">        IntStream.range(0, numHosts)</span>
<span class="nc" id="L974">                .parallel()</span>
<span class="nc" id="L975">                .forEach(</span>
                        i -&gt;
                        {
<span class="nc" id="L978">                            String ip = instances.get(i).getPrivateIpAddress();</span>
<span class="nc" id="L979">                            String id = instances.get(i).getInstanceId();</span>
<span class="nc" id="L980">                            logger.info(&quot;starting process termination on: &quot; + id + &quot; @ &quot; + ip);</span>
<span class="nc" id="L981">                            scriptExecutor.executeStopProcess(ip, processName);</span>
<span class="nc" id="L982">                            executionStateCache.setHealProcess(true);</span>
<span class="nc" id="L983">                            executionStateCache.addUnHealthyInstance(instances.get(i));</span>
<span class="nc" id="L984">                        });</span>
<span class="nc" id="L985">    }</span>

    /**
     * Finds instances that match the name provided.
     *
     * @param name name to match
     * @return List of EC2InstanceTO representing instances with matching name
     */
    public List&lt;EC2InstanceTO&gt; findInstancesByName(String name) {
<span class="nc bnc" id="L994" title="All 2 branches missed.">        if (name == null) {</span>
<span class="nc" id="L995">            return null;</span>
        }
<span class="nc" id="L997">        return ec2Raider.getInstancesByName(name);</span>
    }

    /**
     * Finds instances that match the tag provided.
     *
     * @param tagString tag to match in the form of key:value
     * @return List of EC2InstanceTO representing instances with matching tag
     */
    public List&lt;EC2InstanceTO&gt; findAllInstancesByTag(String tagString) {
<span class="nc bnc" id="L1007" title="All 2 branches missed.">        if (tagString == null) {</span>
<span class="nc" id="L1008">            return null;</span>
        }

<span class="nc" id="L1011">        String[] arr = tagString.split(&quot;:&quot;);</span>
<span class="nc" id="L1012">        List&lt;Tag&gt; tags = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L1013">        Tag tag = new Tag();</span>
<span class="nc" id="L1014">        tag.setKey(arr[0]);</span>
<span class="nc" id="L1015">        tag.setValue(arr[1]);</span>
<span class="nc" id="L1016">        tags.add(tag);</span>

<span class="nc" id="L1018">        return ec2Raider.getInstancesFromAnyTags(tags);</span>
    }

    /**
     * Returns a EC2InstanceTO representing the instance with the provided id
     *
     * @param id instance id
     * @return EC2InstanceTO representing the instance with the provided id
     */
    public EC2InstanceTO getInstanceFromID(String id) {
<span class="nc" id="L1028">        return ec2Raider.getEC2InstanceById(id);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.3.201901230119</span></div></body></html>